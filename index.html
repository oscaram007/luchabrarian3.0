<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wrestler's Rescue Mission - 16-Bit Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: #000;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #gameContainer {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: #000;
        }
        canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: #000;
            border: 2px solid #FFD700;
            font-size: 12px;
            z-index: 10;
            pointer-events: none;
            color: #FFF;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        h1 {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            color: #FFFF00;
            text-shadow: 2px 2px 0px #0000FF;
            z-index: 10;
            font-size: 24px;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <h1>WRESTLER'S RESCUE</h1>
    <div id="info">
        BELTS: <span id="beltCount">0</span>/<span id="totalBelts">0</span> | 
        RINGS: <span id="tacoCount">0</span> | 
        KEYS: <span id="keyInventory">-</span>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Force pixel-perfect rendering
        ctx.imageSmoothingEnabled = false;

        let scale = 1;
        const baseWidth = 640;  // 32-bit resolution (doubled)
        const baseHeight = 480;

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const scaleX = Math.floor(containerWidth / baseWidth);
            const scaleY = Math.floor(containerHeight / baseHeight);
            scale = Math.max(1, Math.min(scaleX, scaleY));
            
            canvas.width = baseWidth;
            canvas.height = baseHeight;
            
            canvas.style.width = (baseWidth * scale) + 'px';
            canvas.style.height = (baseHeight * scale) + 'px';
            
            game.width = baseWidth;
            game.height = baseHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);

        // 32-bit expanded color palette (more shades and colors)
        const PALETTE = {
            SKY_LIGHT: '#B0E0FF',
            SKY_MID1: '#87CEEB',
            SKY_MID2: '#6BB6E8',
            SKY_MID3: '#4A9EDD',
            SKY_DARK1: '#2A7AC0',
            SKY_DARK2: '#1E5A8E',
            SKY_DARK3: '#123A5C',
            GROUND: '#8B4513',
            GROUND_DARK: '#5C2E0F',
            GROUND_MID: '#734010',
            GROUND_LIGHT: '#A0522D',
            GROUND_LIGHTER: '#BC6F3C',
            GRASS: '#32CD32',
            GRASS_MID: '#28A428',
            GRASS_DARK: '#228B22',
            GRASS_DARKER: '#1A6B1A',
            PLATFORM_1: '#CD853F',
            PLATFORM_2: '#DEB887',
            PLATFORM_3: '#F5DEB3',
            BLUE: '#0066FF',
            BLUE_LIGHT: '#4499FF',
            BLUE_LIGHTER: '#77AAFF',
            BLUE_MID: '#0055DD',
            BLUE_DARK: '#0044BB',
            BLUE_DARKER: '#003388',
            RED: '#FF3333',
            RED_LIGHT: '#FF6666',
            RED_LIGHTER: '#FF9999',
            RED_MID: '#DD2222',
            RED_DARK: '#BB1111',
            RED_DARKER: '#880000',
            GOLD: '#FFD700',
            GOLD_LIGHT: '#FFEC8B',
            GOLD_LIGHTER: '#FFF8DC',
            GOLD_MID: '#ECBE00',
            GOLD_DARK: '#B8860B',
            GOLD_DARKER: '#8B6508',
            WHITE: '#FFFFFF',
            BLACK: '#000000',
            PEACH: '#FFDAB9',
            PEACH_LIGHT: '#FFE4C4',
            PEACH_MID: '#FCCBA9',
            PEACH_DARK: '#EEC591',
            PEACH_DARKER: '#D4A76A',
            ORANGE: '#FF8C00',
            ORANGE_LIGHT: '#FFA347',
            ORANGE_MID: '#ED7900',
            ORANGE_DARK: '#CD6600',
            ORANGE_DARKER: '#A04F00',
            GREEN: '#00FF00',
            GREEN_LIGHT: '#66FF66',
            GREEN_DARK: '#00CC00',
            PINK: '#FF69B4',
            PINK_LIGHT: '#FFB6D9',
            PURPLE: '#9370DB',
            CYAN: '#00FFFF',
            CYAN_DARK: '#00CCCC',
            YELLOW: '#FFFF00'
        };

        // Dithering pattern for texture (reduced use in 32-bit)
        function drawDither(x, y, width, height, color1, color2) {
            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    ctx.fillStyle = ((i + j) % 2 === 0) ? color1 : color2;
                    ctx.fillRect(x + i, y + j, 1, 1);
                }
            }
        }

        // Alpha blending for 32-bit transparency
        function drawAlphaRect(x, y, width, height, color, alpha) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
            ctx.globalAlpha = 1;
        }

        // Gradient helper for 32-bit shading
        function drawGradientRect(x, y, width, height, color1, color2, horizontal = false) {
            const gradient = horizontal ? 
                ctx.createLinearGradient(x, y, x + width, y) :
                ctx.createLinearGradient(x, y, x, y + height);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }

        // Draw pixel-perfect rectangle
        function drawPixelRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), width, height);
        }

        // Draw pixel-perfect circle (for sprites)
        function drawPixelCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            const r2 = radius * radius;
            for (let i = -radius; i <= radius; i++) {
                for (let j = -radius; j <= radius; j++) {
                    if (i * i + j * j <= r2) {
                        ctx.fillRect(Math.floor(x) + i, Math.floor(y) + j, 1, 1);
                    }
                }
            }
        }

        // Game state
        const game = {
            width: baseWidth,
            height: baseHeight,
            gravity: 0.4,
            running: true,
            showVictory: false,
            victoryTimer: 0,
            frameCount: 0,
            scrollX: 0
        };

        // Parallax layers
        const bgScroll = { far: 0, mid: 0, near: 0 };

        // Particle system
        const particles = [];

        // Player object (doubled size for 32-bit resolution)
        const player = {
            x: 80,
            y: 80,
            width: 32,
            height: 32,
            velocityX: 0,
            velocityY: 0,
            speed: 3,
            jumpPower: 7,
            climbSpeed: 2.5,
            onGround: false,
            onLadder: false,
            facing: 1, // 1 = right, -1 = left
            animFrame: 0,
            animTimer: 0
        };

        // Platforms (scaled 2x for higher resolution)
        const platforms = [
            { x: 0, y: 440, width: 640, height: 40 }, // Ground
            { x: 160, y: 360, width: 120, height: 16 },
            { x: 360, y: 280, width: 120, height: 16 },
            { x: 80, y: 200, width: 120, height: 16 },
            { x: 400, y: 160, width: 160, height: 16 }
        ];

        // Ladders (scaled 2x)
        const ladders = [
            { x: 320, y: 280, width: 24, height: 160 },
            { x: 144, y: 200, width: 24, height: 160 },
            { x: 440, y: 160, width: 24, height: 120 }
        ];

        // Belts (scaled 2x)
        const belts = [
            { x: 200, y: 328, width: 28, height: 20, collected: false },
            { x: 400, y: 248, width: 28, height: 20, collected: false },
            { x: 120, y: 168, width: 28, height: 20, collected: false },
            { x: 480, y: 128, width: 28, height: 20, collected: false },
            { x: 560, y: 410, width: 28, height: 20, collected: false }
        ];

        // Rings (scaled 2x)
        const rings = [
            { x: 240, y: 420, width: 16, height: 16, collected: false, frame: 0 },
            { x: 416, y: 270, width: 16, height: 16, collected: false, frame: 0 },
            { x: 160, y: 190, width: 16, height: 16, collected: false, frame: 0 },
            { x: 520, y: 150, width: 16, height: 16, collected: false, frame: 0 },
            { x: 360, y: 420, width: 16, height: 16, collected: false, frame: 0 }
        ];

        // Doors (scaled 2x)
        const doors = [
            { x: 40, y: 384, width: 48, height: 56, locked: true, keyColor: 'red' }
        ];

        // Keys (scaled 2x)
        const keys = [
            { x: 496, y: 136, width: 16, height: 12, color: 'red', collected: false }
        ];

        // Input
        const keys_pressed = {};
        window.addEventListener('keydown', (e) => {
            keys_pressed[e.key.toLowerCase()] = true;
            if (e.key === ' ' || e.key.toLowerCase() === 'w') e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys_pressed[e.key.toLowerCase()] = false;
        });

        let beltsCollected = 0;
        let ringsCollected = 0;
        const totalBelts = belts.length;

        document.getElementById('totalBelts').textContent = totalBelts;

        function updateUI() {
            document.getElementById('beltCount').textContent = beltsCollected;
            document.getElementById('tacoCount').textContent = ringsCollected;
            const collectedKeys = keys.filter(k => k.collected).map(k => k.color[0].toUpperCase());
            document.getElementById('keyInventory').textContent = collectedKeys.length > 0 ? collectedKeys.join('') : '-';
        }

        // Particle effects
        function createRingSparkle(x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2 - 1,
                    life: 20,
                    color: PALETTE.GOLD
                });
            }
        }

        function createStars(x, y, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3 - 1,
                    life: 15,
                    color: [PALETTE.GOLD, PALETTE.WHITE, PALETTE.PINK][i % 3]
                });
            }
        }

        function updatePlayer() {
            game.frameCount++;
            
            // Animation
            if (Math.abs(player.velocityX) > 0.1 && player.onGround) {
                player.animTimer++;
                if (player.animTimer > 4) {
                    player.animFrame = (player.animFrame + 1) % 4;
                    player.animTimer = 0;
                }
            } else {
                player.animFrame = 0;
            }

            const moveLeft = keys_pressed['arrowleft'] || keys_pressed['a'];
            const moveRight = keys_pressed['arrowright'] || keys_pressed['d'];
            const jump = keys_pressed[' '] || keys_pressed['w'];
            const climbUp = keys_pressed['arrowup'];
            const climbDown = keys_pressed['arrowdown'];

            if (moveLeft) player.facing = -1;
            if (moveRight) player.facing = 1;

            // Ladder check
            player.onLadder = false;
            for (let ladder of ladders) {
                if (player.x + player.width > ladder.x &&
                    player.x < ladder.x + ladder.width &&
                    player.y + player.height > ladder.y &&
                    player.y < ladder.y + ladder.height) {
                    player.onLadder = true;
                    break;
                }
            }

            if (player.onLadder) {
                player.velocityY = 0;
                if (climbUp) player.y -= player.climbSpeed;
                if (climbDown) player.y += player.climbSpeed;
            } else {
                player.velocityY += game.gravity;
            }

            // Movement
            if (moveLeft) {
                player.velocityX = -player.speed;
            } else if (moveRight) {
                player.velocityX = player.speed;
            } else {
                player.velocityX *= 0.7;
            }

            // Jump
            if (jump && player.onGround && !player.onLadder) {
                player.velocityY = -player.jumpPower;
            }

            player.x += player.velocityX;
            player.y += player.velocityY;

            // Platform collision
            player.onGround = false;
            for (let platform of platforms) {
                if (player.velocityY >= 0 &&
                    player.y + player.height >= platform.y &&
                    player.y + player.height <= platform.y + 8 &&
                    player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width) {
                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    player.onGround = true;
                }
            }

            // Bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > game.width) player.x = game.width - player.width;
            if (player.y > game.height) {
                player.y = 0;
                player.velocityY = 0;
            }

            // Collect belts
            for (let belt of belts) {
                if (!belt.collected &&
                    player.x < belt.x + belt.width &&
                    player.x + player.width > belt.x &&
                    player.y < belt.y + belt.height &&
                    player.y + player.height > belt.y) {
                    belt.collected = true;
                    beltsCollected++;
                    updateUI();
                    createStars(belt.x + belt.width / 2, belt.y + belt.height / 2, 12);
                    if (beltsCollected >= totalBelts) {
                        game.showVictory = true;
                    }
                }
            }

            // Collect rings
            for (let ring of rings) {
                if (!ring.collected &&
                    player.x < ring.x + ring.width &&
                    player.x + player.width > ring.x &&
                    player.y < ring.y + ring.height &&
                    player.y + player.height > ring.y) {
                    ring.collected = true;
                    ringsCollected++;
                    updateUI();
                    createRingSparkle(ring.x + ring.width / 2, ring.y + ring.height / 2);
                }
            }

            // Collect keys
            for (let key of keys) {
                if (!key.collected &&
                    player.x < key.x + key.width &&
                    player.x + player.width > key.x &&
                    player.y < key.y + key.height &&
                    player.y + player.height > key.y) {
                    key.collected = true;
                    updateUI();
                    createStars(key.x + key.width / 2, key.y + key.height / 2, 8);
                }
            }

            // Doors
            for (let door of doors) {
                if (door.locked &&
                    player.x < door.x + door.width &&
                    player.x + player.width > door.x &&
                    player.y < door.y + door.height &&
                    player.y + player.height > door.y) {
                    const hasKey = keys.find(k => k.color === door.keyColor && k.collected);
                    if (hasKey) {
                        door.locked = false;
                        createStars(door.x + door.width / 2, door.y + door.height / 2, 20);
                    }
                }
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        // Draw sky with smooth gradients (32-bit style)
        function drawBackground() {
            // Multi-layer sky gradient
            drawGradientRect(0, 0, game.width, 120, PALETTE.SKY_LIGHT, PALETTE.SKY_MID1);
            drawGradientRect(0, 120, game.width, 120, PALETTE.SKY_MID2, PALETTE.SKY_MID3);
            drawGradientRect(0, 240, game.width, 120, PALETTE.SKY_DARK1, PALETTE.SKY_DARK2);
            drawGradientRect(0, 360, game.width, 120, PALETTE.SKY_DARK2, PALETTE.SKY_DARK3);

            // Pixel clouds with transparency
            bgScroll.far += 0.2;
            for (let i = 0; i < 5; i++) {
                const cloudX = Math.floor((i * 160 + bgScroll.far) % (game.width + 80)) - 40;
                const cloudY = 40 + i * 30;
                
                // Cloud shadow with alpha
                drawAlphaRect(cloudX + 4, cloudY + 4, 48, 16, PALETTE.BLACK, 0.2);
                
                // Cloud body (larger, more detailed)
                drawPixelRect(cloudX, cloudY, 48, 16, PALETTE.WHITE);
                drawPixelRect(cloudX + 8, cloudY - 8, 32, 8, PALETTE.WHITE);
                drawPixelRect(cloudX + 16, cloudY - 12, 16, 4, PALETTE.WHITE);
                
                // Cloud shading with alpha
                drawAlphaRect(cloudX, cloudY + 12, 48, 4, PALETTE.SKY_MID1, 0.3);
            }

            // Distant hills with gradient
            bgScroll.mid += 0.3;
            const hillY = 320;
            ctx.fillStyle = PALETTE.GREEN_DARK;
            ctx.beginPath();
            ctx.moveTo(0, hillY);
            for (let x = 0; x <= game.width; x += 4) {
                const y = hillY + Math.sin((x + bgScroll.mid) * 0.02) * 20;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(game.width, game.height);
            ctx.lineTo(0, game.height);
            ctx.closePath();
            ctx.fill();
            
            // Hill shading with alpha
            drawAlphaRect(0, hillY, game.width, 40, PALETTE.BLACK, 0.2);
        }

        // Draw platforms with gradients (32-bit style)
        function drawPlatforms() {
            for (let platform of platforms) {
                const px = Math.floor(platform.x);
                const py = Math.floor(platform.y);
                
                // Platform with gradient shading
                drawGradientRect(px, py, platform.width, platform.height, 
                    PALETTE.PLATFORM_2, PALETTE.PLATFORM_1);
                
                // Top edge highlight
                drawPixelRect(px, py, platform.width, 2, PALETTE.PLATFORM_3);
                
                // Subtle texture dither (less than 16-bit)
                for (let i = 0; i < platform.width; i += 4) {
                    for (let j = 4; j < platform.height; j += 4) {
                        if ((i + j) % 8 === 0) {
                            drawAlphaRect(px + i, py + j, 2, 2, PALETTE.PLATFORM_3, 0.3);
                        }
                    }
                }
                
                // Black outline
                drawPixelRect(px, py, platform.width, 1, PALETTE.BLACK);
                drawPixelRect(px, py + platform.height - 1, platform.width, 1, PALETTE.BLACK);
                drawPixelRect(px, py, 1, platform.height, PALETTE.BLACK);
                drawPixelRect(px + platform.width - 1, py, 1, platform.height, PALETTE.BLACK);
                
                // Detailed grass on smaller platforms
                if (platform.height === 16 && py < 400) {
                    for (let i = 0; i < platform.width; i += 6) {
                        const grassH = 6 + Math.floor(Math.random() * 4);
                        // Multi-tone grass with gradient
                        drawGradientRect(px + i, py - grassH, 3, grassH, 
                            PALETTE.GRASS, PALETTE.GRASS_DARK);
                        drawPixelRect(px + i, py - grassH, 1, 1, PALETTE.GRASS_MID);
                        
                        // Additional grass variety
                        if (i % 12 === 0) {
                            drawGradientRect(px + i + 3, py - grassH + 2, 2, grassH - 2,
                                PALETTE.GRASS_MID, PALETTE.GRASS_DARKER);
                        }
                    }
                }
            }
        }

        // Draw ladders with gradient shading
        function drawLadders() {
            for (let ladder of ladders) {
                const lx = Math.floor(ladder.x);
                const ly = Math.floor(ladder.y);
                
                // Ladder with gradient
                drawGradientRect(lx, ly, ladder.width, ladder.height, 
                    PALETTE.ORANGE_LIGHT, PALETTE.ORANGE);
                
                // Rails with depth
                drawGradientRect(lx + 2, ly, 4, ladder.height, 
                    PALETTE.ORANGE, PALETTE.ORANGE_DARK, true);
                drawGradientRect(lx + ladder.width - 6, ly, 4, ladder.height, 
                    PALETTE.ORANGE, PALETTE.ORANGE_DARK, true);
                
                // Rungs with highlights
                for (let i = 0; i < ladder.height; i += 16) {
                    drawGradientRect(lx, ly + i, ladder.width, 4, 
                        PALETTE.ORANGE_MID, PALETTE.ORANGE_DARK);
                    drawPixelRect(lx, ly + i, ladder.width, 1, PALETTE.ORANGE_LIGHT);
                }
                
                // Outline
                drawPixelRect(lx, ly, ladder.width, 1, PALETTE.BLACK);
                drawPixelRect(lx, ly + ladder.height - 1, ladder.width, 1, PALETTE.BLACK);
                drawPixelRect(lx, ly, 1, ladder.height, PALETTE.BLACK);
                drawPixelRect(lx + ladder.width - 1, ly, 1, ladder.height, PALETTE.BLACK);
            }
        }

        // Draw doors with gradient and glow
        function drawDoors() {
            for (let door of doors) {
                const dx = Math.floor(door.x);
                const dy = Math.floor(door.y);
                
                const doorColor = door.locked ? PALETTE.RED_DARK : PALETTE.GREEN_DARK;
                const doorLight = door.locked ? PALETTE.RED_MID : PALETTE.GREEN;
                
                // Door body with gradient
                drawGradientRect(dx, dy, door.width, door.height, doorLight, doorColor, true);
                
                // Inner panel
                drawGradientRect(dx + 4, dy + 4, door.width - 8, door.height - 8, 
                    doorColor, doorLight, true);
                
                // Doorknob with metallic gradient
                const knobX = dx + door.width - 12;
                const knobY = dy + door.height / 2 - 3;
                drawGradientRect(knobX, knobY, 6, 6, PALETTE.GOLD_LIGHT, PALETTE.GOLD_DARK);
                drawPixelRect(knobX, knobY, 2, 2, PALETTE.GOLD_LIGHTER);
                
                // Lock with glow
                if (door.locked) {
                    // Glow effect
                    drawAlphaRect(dx + door.width / 2 - 10, dy + 12, 20, 20, PALETTE.GOLD, 0.3);
                    
                    drawGradientRect(dx + door.width / 2 - 6, dy + 16, 12, 16, 
                        PALETTE.GOLD_LIGHT, PALETTE.GOLD_DARK);
                    drawGradientRect(dx + door.width / 2 - 8, dy + 12, 16, 8, 
                        PALETTE.GOLD_LIGHT, PALETTE.GOLD);
                    drawPixelRect(dx + door.width / 2 - 6, dy + 16, 2, 2, PALETTE.GOLD_LIGHTER);
                }
                
                // Outline
                drawPixelRect(dx, dy, door.width, 1, PALETTE.BLACK);
                drawPixelRect(dx, dy + door.height - 1, door.width, 1, PALETTE.BLACK);
                drawPixelRect(dx, dy, 1, door.height, PALETTE.BLACK);
                drawPixelRect(dx + door.width - 1, dy, 1, door.height, PALETTE.BLACK);
            }
        }

        // Draw keys with glow
        function drawKeys() {
            for (let key of keys) {
                if (key.collected) continue;
                
                const kx = Math.floor(key.x);
                const ky = Math.floor(key.y);
                const keyColor = key.color === 'red' ? PALETTE.RED : PALETTE.BLUE;
                const keyLight = key.color === 'red' ? PALETTE.RED_LIGHT : PALETTE.BLUE_LIGHT;
                
                // Glow effect
                const glowPulse = Math.sin(game.frameCount * 0.1) * 0.2 + 0.3;
                drawAlphaRect(kx - 2, ky - 2, 12, 12, keyLight, glowPulse);
                
                // Key head with gradient
                drawGradientRect(kx, ky, 8, 8, keyLight, keyColor);
                drawPixelRect(kx + 2, ky + 2, 4, 4, PALETTE.BLACK);
                drawPixelRect(kx, ky, 2, 2, PALETTE.RED_LIGHTER);
                
                // Key shaft
                drawGradientRect(kx + 8, ky + 2, 8, 4, keyLight, keyColor);
                
                // Key teeth
                drawPixelRect(kx + 14, ky, 2, 4, keyColor);
                drawPixelRect(kx + 14, ky + 8, 2, 4, keyColor);
            }
        }

        // Draw rings with enhanced animation
        function drawRings() {
            for (let ring of rings) {
                if (ring.collected) continue;
                
                ring.frame = (ring.frame + 0.15) % 4;
                const frame = Math.floor(ring.frame);
                
                const rx = Math.floor(ring.x);
                const ry = Math.floor(ring.y);
                
                // Ring animation frames (scaled 2x)
                const widths = [16, 12, 8, 12];
                const w = widths[frame];
                const offset = Math.floor((16 - w) / 2);
                
                // Glow effect
                const glowAlpha = Math.sin(ring.frame * Math.PI) * 0.3 + 0.3;
                drawAlphaRect(rx + offset - 2, ry - 2, w + 4, 20, PALETTE.GOLD, glowAlpha);
                
                // Outer ring with gradient
                drawGradientRect(rx + offset, ry, w, 16, PALETTE.GOLD_LIGHT, PALETTE.GOLD);
                
                // Inner hole
                if (w > 8) {
                    const holeW = w - 8;
                    const holeOffset = Math.floor((w - holeW) / 2);
                    drawPixelRect(rx + offset + holeOffset, ry + 4, holeW, 8, PALETTE.SKY_DARK2);
                }
                
                // Highlights
                if (w > 8) {
                    drawPixelRect(rx + offset, ry, w, 3, PALETTE.GOLD_LIGHTER);
                    drawPixelRect(rx + offset, ry, 3, 16, PALETTE.GOLD_LIGHTER);
                }
            }
        }

        // Draw belts with gradient and gems
        function drawBelts() {
            for (let belt of belts) {
                if (belt.collected) continue;
                
                const bx = Math.floor(belt.x);
                const by = Math.floor(belt.y);
                
                // Pulse effect
                const pulse = Math.sin(game.frameCount * 0.05) * 0.15 + 1;
                const pulseOffset = Math.floor((1 - pulse) * belt.width / 2);
                
                // Belt strap with gradient
                drawGradientRect(bx + pulseOffset, by, belt.width * pulse, belt.height, 
                    PALETTE.GROUND, PALETTE.GROUND_DARK);
                
                // Gold plate
                drawGradientRect(bx + 4 + pulseOffset, by + 4, (belt.width - 8) * pulse, belt.height - 8, 
                    PALETTE.GOLD_LIGHTER, PALETTE.GOLD);
                drawPixelRect(bx + 4 + pulseOffset, by + 4, (belt.width - 8) * pulse, 3, PALETTE.GOLD_LIGHTER);
                
                // Center gem with sparkle
                const gemX = bx + belt.width / 2 - 4;
                const gemY = by + belt.height / 2 - 2;
                drawGradientRect(gemX, gemY, 8, 4, PALETTE.RED_LIGHT, PALETTE.RED_DARK);
                drawPixelRect(gemX, gemY, 2, 2, PALETTE.RED_LIGHTER);
                
                // Side gems
                drawPixelRect(bx + 6, by + belt.height / 2 - 1, 3, 3, PALETTE.CYAN);
                drawPixelRect(bx + belt.width - 9, by + belt.height / 2 - 1, 3, 3, PALETTE.PINK);
                
                // Outline
                drawPixelRect(bx, by, belt.width, 1, PALETTE.BLACK);
                drawPixelRect(bx, by + belt.height - 1, belt.width, 1, PALETTE.BLACK);
                drawPixelRect(bx, by, 1, belt.height, PALETTE.BLACK);
                drawPixelRect(bx + belt.width - 1, by, 1, belt.height, PALETTE.BLACK);
            }
        }

        // Draw player sprite (32-bit with gradients and detail)
        function drawPlayer() {
            const px = Math.floor(player.x);
            const py = Math.floor(player.y);
            
            ctx.save();
            if (player.facing === -1) {
                ctx.translate(px + player.width, py);
                ctx.scale(-1, 1);
                ctx.translate(0, 0);
            } else {
                ctx.translate(px, py);
            }
            
            // Shadow with alpha
            drawAlphaRect(-2, player.height - 2, player.width + 4, 4, PALETTE.BLACK, 0.3);
            
            // Body (blue) with gradient shading
            drawPixelCircle(16, 16, 14, PALETTE.BLUE_DARKER);
            drawPixelCircle(16, 16, 12, PALETTE.BLUE_DARK);
            drawPixelCircle(15, 15, 10, PALETTE.BLUE);
            drawPixelCircle(14, 14, 8, PALETTE.BLUE_LIGHT);
            
            // Belly patch with gradient
            drawGradientRect(10, 12, 12, 12, PALETTE.PEACH_LIGHT, PALETTE.PEACH);
            drawGradientRect(12, 14, 8, 8, PALETTE.PEACH, PALETTE.PEACH_DARK);
            
            // Head with shading
            drawPixelCircle(16, 8, 8, PALETTE.BLUE_DARK);
            drawPixelCircle(15, 7, 7, PALETTE.BLUE);
            drawPixelRect(18, 6, 4, 2, PALETTE.BLUE_LIGHT);
            
            // Spikes with gradient
            drawGradientRect(20, 6, 6, 4, PALETTE.BLUE_LIGHT, PALETTE.BLUE);
            drawGradientRect(22, 10, 4, 4, PALETTE.BLUE, PALETTE.BLUE_DARK);
            drawGradientRect(24, 14, 2, 4, PALETTE.BLUE, PALETTE.BLUE_DARKER);
            drawPixelRect(20, 6, 2, 2, PALETTE.BLUE_LIGHTER);
            
            // Eyes with more detail
            drawPixelRect(8, 6, 6, 6, PALETTE.WHITE);
            drawPixelRect(18, 6, 6, 6, PALETTE.WHITE);
            
            // Pupils with gradient
            drawGradientRect(10, 8, 4, 4, PALETTE.BLACK, PALETTE.BLUE_DARKER);
            drawGradientRect(20, 8, 4, 4, PALETTE.BLACK, PALETTE.BLUE_DARKER);
            
            // Eye shine
            drawPixelRect(10, 8, 2, 2, PALETTE.WHITE);
            drawPixelRect(20, 8, 2, 2, PALETTE.WHITE);
            drawAlphaRect(11, 9, 2, 2, PALETTE.WHITE, 0.5);
            drawAlphaRect(21, 9, 2, 2, PALETTE.WHITE, 0.5);
            
            // Mouth (curved)
            drawPixelRect(14, 14, 4, 1, PALETTE.BLACK);
            drawPixelRect(13, 15, 1, 1, PALETTE.BLACK);
            drawPixelRect(18, 15, 1, 1, PALETTE.BLACK);
            
            // Arms with gradient shading
            drawGradientRect(4, 14, 4, 8, PALETTE.PEACH_LIGHT, PALETTE.PEACH_DARK);
            drawGradientRect(24, 16, 4, 8, PALETTE.PEACH_LIGHT, PALETTE.PEACH_DARK);
            drawPixelRect(4, 14, 2, 2, PALETTE.PEACH_LIGHT);
            drawPixelRect(24, 16, 2, 2, PALETTE.PEACH_LIGHT);
            
            // Legs with animation
            if (player.animFrame % 2 === 0) {
                drawGradientRect(8, 26, 6, 6, PALETTE.BLUE_LIGHT, PALETTE.BLUE);
                drawGradientRect(18, 26, 6, 6, PALETTE.BLUE_LIGHT, PALETTE.BLUE);
            } else {
                drawGradientRect(10, 26, 6, 6, PALETTE.BLUE_LIGHT, PALETTE.BLUE);
                drawGradientRect(16, 26, 6, 6, PALETTE.BLUE_LIGHT, PALETTE.BLUE);
            }
            
            // Shoes (red) with gradient and details
            const shoe1X = player.animFrame % 2 === 0 ? 6 : 8;
            const shoe2X = player.animFrame % 2 === 0 ? 18 : 16;
            
            drawGradientRect(shoe1X, 28, 8, 4, PALETTE.RED_LIGHT, PALETTE.RED);
            drawGradientRect(shoe2X, 28, 8, 4, PALETTE.RED_LIGHT, PALETTE.RED);
            
            // Shoe stripe (white)
            drawPixelRect(shoe1X, 30, 8, 2, PALETTE.WHITE);
            drawPixelRect(shoe2X, 30, 8, 2, PALETTE.WHITE);
            
            // Shoe highlights
            drawPixelRect(shoe1X, 28, 3, 2, PALETTE.RED_LIGHTER);
            drawPixelRect(shoe2X, 28, 3, 2, PALETTE.RED_LIGHTER);
            
            // Shoe buckles with metallic shine
            drawGradientRect(shoe1X + 2, 30, 4, 2, PALETTE.GOLD_LIGHTER, PALETTE.GOLD);
            drawGradientRect(shoe2X + 2, 30, 4, 2, PALETTE.GOLD_LIGHTER, PALETTE.GOLD);
            
            ctx.restore();
        }

        // Draw particles with transparency and glow
        function drawParticles() {
            for (let p of particles) {
                const alpha = p.life / 20;
                
                // Glow effect
                drawAlphaRect(Math.floor(p.x) - 2, Math.floor(p.y) - 2, 6, 6, p.color, alpha * 0.3);
                
                // Particle core
                drawAlphaRect(Math.floor(p.x), Math.floor(p.y), 3, 3, p.color, alpha);
                
                // Bright center
                drawAlphaRect(Math.floor(p.x) + 1, Math.floor(p.y) + 1, 1, 1, PALETTE.WHITE, alpha * 0.8);
            }
        }

        // Victory screen
        function drawVictoryScreen() {
            game.victoryTimer++;
            
            // Flash background
            const flashColor = (Math.floor(game.victoryTimer / 4) % 2 === 0) ? PALETTE.GOLD : PALETTE.BLUE;
            ctx.globalAlpha = 0.3;
            drawPixelRect(0, 0, game.width, game.height, flashColor);
            ctx.globalAlpha = 1;
            
            // Text
            ctx.fillStyle = PALETTE.GOLD;
            ctx.font = 'bold 16px "Courier New"';
            ctx.fillText('YOU WIN!', game.width / 2 - 40, game.height / 2 - 20);
            
            ctx.fillStyle = PALETTE.WHITE;
            ctx.font = '12px "Courier New"';
            ctx.fillText('RINGS: ' + ringsCollected, game.width / 2 - 35, game.height / 2 + 10);
            
            if (Math.floor(game.victoryTimer / 20) % 2 === 0) {
                ctx.fillText('CLICK TO RESTART', game.width / 2 - 60, game.height / 2 + 40);
            }
        }

        // Reset
        function resetGame() {
            player.x = 80;
            player.y = 80;
            player.velocityX = 0;
            player.velocityY = 0;
            beltsCollected = 0;
            ringsCollected = 0;
            
            belts.forEach(b => b.collected = false);
            rings.forEach(r => { r.collected = false; r.frame = 0; });
            keys.forEach(k => k.collected = false);
            doors.forEach(d => d.locked = true);
            
            particles.length = 0;
            game.victoryTimer = 0;
            updateUI();
        }

        // Main loop
        function gameLoop() {
            if (!game.running) return;

            // Clear with black
            ctx.fillStyle = PALETTE.BLACK;
            ctx.fillRect(0, 0, game.width, game.height);

            if (game.showVictory) {
                drawBackground();
                drawPlatforms();
                drawLadders();
                drawDoors();
                drawKeys();
                drawRings();
                drawBelts();
                drawPlayer();
                updateParticles();
                drawParticles();
                drawVictoryScreen();
            } else {
                updatePlayer();
                updateParticles();

                drawBackground();
                drawPlatforms();
                drawLadders();
                drawDoors();
                drawKeys();
                drawRings();
                drawBelts();
                drawParticles();
                drawPlayer();
            }

            requestAnimationFrame(gameLoop);
        }

        // Start
        resizeCanvas();
        
        canvas.addEventListener('click', () => {
            if (game.showVictory) {
                game.showVictory = false;
                resetGame();
            }
        });
        
        gameLoop();
    </script>
</body>
</html>
